<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Code/SHS/Machines/Construction/Previews/ConveyorPreview.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/SHS/Machines/Construction/Previews/ConveyorPreview.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.SHS.Machines.Construction.Previews&#10;{&#10;    public class ConveyorPreview : ConstructPreview&#10;    {&#10;        private ConveyorSO conveyorSO;&#10;&#10;        [SerializeField] private MeshFilter meshFilter;&#10;        private HashSet&lt;Direction&gt; directions = new HashSet&lt;Direction&gt;();&#10;        private ConveyorData conveyorData;&#10;&#10;        public override void Initialize(MachineSO machineSO, MachineConstructor constructor)&#10;        {&#10;            base.Initialize(machineSO, constructor);&#10;            conveyorSO = (ConveyorSO)machineSO;&#10;        }&#10;&#10;        public override void SetNextDirection(Direction nextDirection)&#10;        {&#10;            base.SetNextDirection(nextDirection);&#10;            directions.Add(nextDirection);&#10;            Mesh mesh = meshFilter.mesh;&#10;            foreach (ConveyorData conveyorData in conveyorSO.conveyorDataList)&#10;            {&#10;                if (isValidData(conveyorData))&#10;                {&#10;                    mesh = conveyorData.mesh;&#10;                    this.conveyorData = conveyorData;&#10;                }&#10;            }&#10;&#10;            meshFilter.sharedMesh = mesh;&#10;        }&#10;&#10;        public bool isValidData(ConveyorData data)&#10;        {&#10;            foreach (Direction direction in data.OutputDirections)&#10;            {&#10;                if (directions.Contains(direction) == false)&#10;                {&#10;                    return false;&#10;                }&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        public override GameObject Construct()&#10;        {&#10;            if (conveyorData != null)&#10;            {&#10;                GameObject machine = Instantiate(conveyorData.prefab, transform.position, transform.rotation);&#10;                return machine;&#10;            }&#10;&#10;            return base.Construct();&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.SHS.Machines.Construction.Previews&#10;{&#10;    public class ConveyorPreview : ConstructPreview&#10;    {&#10;        private ConveyorSO conveyorSO;&#10;&#10;        [SerializeField] private MeshFilter meshFilter;&#10;        [SerializeField] private MeshRenderer meshRenderer;&#10;        &#10;        private readonly HashSet&lt;Direction&gt; directions = new HashSet&lt;Direction&gt;();&#10;        private ConveyorData selectedData;&#10;&#10;        public override void Initialize(MachineSO machineSO, MachineConstructor constructor)&#10;        {&#10;            base.Initialize(machineSO, constructor);&#10;            conveyorSO = (ConveyorSO)machineSO;&#10;            UpdateMesh();&#10;        }&#10;&#10;        public override void SetNextDirection(Direction nextDirection)&#10;        {&#10;            if (nextDirection == Direction.None)&#10;            {&#10;                directions.Clear();&#10;                UpdateMesh();&#10;                return;&#10;            }&#10;&#10;            if (directions.Contains(nextDirection))&#10;            {&#10;                return;&#10;            }&#10;&#10;            if (directions.Contains(nextDirection.Opposite()))&#10;            {&#10;                directions.Add(nextDirection);&#10;            }&#10;            else if (directions.Count == 0)&#10;            {&#10;                directions.Add(nextDirection);&#10;                directions.Add(nextDirection.Opposite());&#10;            }&#10;            else&#10;            {&#10;                directions.Add(nextDirection);&#10;            }&#10;&#10;            UpdateMesh();&#10;        }&#10;&#10;        private void UpdateMesh()&#10;        {&#10;            if (directions.Count == 0)&#10;            {&#10;                if (meshRenderer != null)&#10;                    meshRenderer.enabled = false;&#10;                return;&#10;            }&#10;&#10;            if (meshRenderer != null)&#10;                meshRenderer.enabled = true;&#10;&#10;            selectedData = conveyorSO.GetMatchingData(directions);&#10;            &#10;            if (selectedData != null)&#10;            {&#10;                meshFilter.sharedMesh = selectedData.mesh;&#10;                &#10;                Quaternion dataRotation = selectedData.GetRotationFor(directions);&#10;                transform.localRotation = dataRotation * MachineSO.rotation;&#10;            }&#10;        }&#10;&#10;        public override GameObject Construct()&#10;        {&#10;            if (selectedData != null)&#10;            {&#10;                GameObject machine = Instantiate(selectedData.prefab, transform.position, transform.rotation);&#10;                return machine;&#10;            }&#10;&#10;            return base.Construct();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/SHS/Machines/ConveyorSO.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/SHS/Machines/ConveyorSO.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using AYellowpaper.SerializedCollections;&#10;using UnityEngine;&#10;using UnityEngine.Serialization;&#10;&#10;namespace Code.SHS.Machines&#10;{&#10;    [CreateAssetMenu(fileName = &quot;new ConveyorSO&quot;, menuName = &quot;Machine/ConveyorSO&quot;, order = 0)]&#10;    public class ConveyorSO : MachineSO&#10;    {&#10;        public List&lt;ConveyorData&gt; conveyorDataList;&#10;&#10;        private void Awake()&#10;        {&#10;            Debug.Log(&quot;Setting up conveyor data&quot;);&#10;            foreach (ConveyorData data in conveyorDataList)&#10;            {&#10;                data.Setup();&#10;            }&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            foreach (ConveyorData data in conveyorDataList)&#10;            {&#10;                data.Setup();&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// 컨베이어 벨트의 입출력 방향과 메시 정보를 담는 데이터 클래스&#10;    /// &lt;/summary&gt;&#10;    [System.Serializable]&#10;    public class ConveyorData&#10;    {&#10;        [SerializeField] private List&lt;Direction&gt; inputDirections;&#10;        [SerializeField] private List&lt;Direction&gt; outputDirections;&#10;        public HashSet&lt;Direction&gt; InputDirections { get; private set; }&#10;        public HashSet&lt;Direction&gt; OutputDirections { get; private set; }&#10;        public Mesh mesh;&#10;        public Quaternion rotation;&#10;        public GameObject prefab;&#10;&#10;        /// &lt;summary&gt;&#10;        /// 직렬화된 List를 HashSet으로 변환하여 초기화합니다.&#10;        /// &lt;/summary&gt;&#10;        public void Setup()&#10;        {&#10;            InputDirections = new HashSet&lt;Direction&gt;(inputDirections);&#10;            OutputDirections = new HashSet&lt;Direction&gt;(outputDirections);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.SHS.Machines&#10;{&#10;    [CreateAssetMenu(fileName = &quot;new ConveyorSO&quot;, menuName = &quot;Machine/ConveyorSO&quot;, order = 0)]&#10;    public class ConveyorSO : MachineSO&#10;    {&#10;        public List&lt;ConveyorData&gt; conveyorDataList;&#10;&#10;        public ConveyorData GetMatchingData(HashSet&lt;Direction&gt; directions)&#10;        {&#10;            foreach (ConveyorData data in conveyorDataList)&#10;            {&#10;                if (data.IsMatch(directions))&#10;                {&#10;                    return data;&#10;                }&#10;            }&#10;&#10;            return null;&#10;        }&#10;    }&#10;&#10;    [System.Serializable]&#10;    public class ConveyorData&#10;    {&#10;        [SerializeField] private List&lt;Direction&gt; directions;&#10;        public Mesh mesh;&#10;        public Quaternion rotation;&#10;        public GameObject prefab;&#10;&#10;        private HashSet&lt;Direction&gt; directionSet;&#10;&#10;        public bool IsMatch(HashSet&lt;Direction&gt; inputDirections)&#10;        {&#10;            if (directionSet == null)&#10;            {&#10;                directionSet = new HashSet&lt;Direction&gt;(directions);&#10;            }&#10;&#10;            if (directionSet.Count != inputDirections.Count)&#10;                return false;&#10;&#10;            foreach (Direction dir in inputDirections)&#10;            {&#10;                if (!directionSet.Contains(dir))&#10;                    return false;&#10;            }&#10;&#10;            return true;&#10;        }&#10;&#10;        public Quaternion GetRotationFor(HashSet&lt;Direction&gt; inputDirections)&#10;        {&#10;            if (directionSet == null)&#10;            {&#10;                directionSet = new HashSet&lt;Direction&gt;(directions);&#10;            }&#10;&#10;            Direction firstInput = Direction.None;&#10;            foreach (Direction dir in inputDirections)&#10;            {&#10;                firstInput = dir;&#10;                break;&#10;            }&#10;&#10;            Direction firstReference = Direction.None;&#10;            foreach (Direction dir in directionSet)&#10;            {&#10;                firstReference = dir;&#10;                break;&#10;            }&#10;&#10;            if (firstInput == Direction.None || firstReference == Direction.None)&#10;                return Quaternion.identity;&#10;&#10;            int rotationSteps = ((int)firstInput - (int)firstReference + 4) % 4;&#10;            return Quaternion.Euler(0, rotationSteps * 90f, 0);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>