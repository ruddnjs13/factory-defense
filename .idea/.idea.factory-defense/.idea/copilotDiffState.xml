<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Code/SHS/Machines/Portal.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/SHS/Machines/Portal.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using System.Linq;&#10;using Chipmunk.GameEvents;&#10;using Chipmunk.Player.Events;&#10;using Code.SHS.Extensions;&#10;using Code.SHS.Machines.Ports;&#10;using Code.SHS.Machines.ShapeResources;&#10;using TMPro;&#10;using UnityEngine;&#10;using UnityEngine.Serialization;&#10;&#10;namespace Code.SHS.Machines&#10;{&#10;    public class Portal : BaseMachine, IInputMachine&#10;    {&#10;        [SerializeField] private InputPort[] inputPorts;&#10;        [SerializeField] private List&lt;ShapeResourceSO&gt; allShapeResourceSo;&#10;&#10;        public InputPort GetAvailableInputPort(OutputPort outputPort)&#10;        {&#10;            foreach (InputPort inputPort in inputPorts)&#10;            {&#10;                if (inputPort.CanAcceptInputFrom(outputPort))&#10;                    return inputPort;&#10;            }&#10;&#10;            return null;&#10;        }&#10;&#10;        public bool CanAcceptResource()&#10;        {&#10;            return true;&#10;        }&#10;&#10;        public void InputPortResourceTransferComplete(InputPort inputPort)&#10;        {&#10;            ShapeResource resource = inputPort.Pop();&#10;            int shapeTier = 0;&#10;            foreach (ShapeResourceSO shapeResourceSo in allShapeResourceSo)&#10;            {&#10;                if (IsContainPiece(resource, shapeResourceSo))&#10;                    shapeTier++;&#10;            }&#10;&#10;            int amount = 0;&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                if (resource.ShapePieces[i].ShapePieceSo != null)&#10;                    amount += resource.ShapePieces[i].ShapePieceSo.resourceAmount;&#10;            }&#10;&#10;            EventBus.Raise(new ResourceEvent(amount * shapeTier));&#10;        }&#10;&#10;        private bool IsContainPiece(ShapeResource resource, ShapeResourceSO shapeResourceSo)&#10;        {&#10;            if (resource.ShapePieces.Any(piece =&gt; shapeResourceSo.ShapePieces.Contains(piece.ShapePieceSo)))&#10;            {&#10;                return true;&#10;            }&#10;&#10;            return false;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using System.Linq;&#10;using Chipmunk.GameEvents;&#10;using Chipmunk.Player.Events;&#10;using Code.SHS.Extensions;&#10;using Code.SHS.Machines.Ports;&#10;using Code.SHS.Machines.ShapeResources;&#10;using TMPro;&#10;using UnityEngine;&#10;using UnityEngine.Serialization;&#10;&#10;namespace Code.SHS.Machines&#10;{&#10;    public class Portal : BaseMachine, IInputMachine&#10;    {&#10;        [SerializeField] private InputPort[] inputPorts;&#10;        [SerializeField] private List&lt;ShapeResourceSO&gt; allShapeResourceSo;&#10;&#10;        public InputPort GetAvailableInputPort(OutputPort outputPort)&#10;        {&#10;            foreach (InputPort inputPort in inputPorts)&#10;            {&#10;                if (inputPort.CanAcceptInputFrom(outputPort))&#10;                    return inputPort;&#10;            }&#10;&#10;            return null;&#10;        }&#10;&#10;        public bool CanAcceptResource()&#10;        {&#10;            return true;&#10;        }&#10;&#10;        public void InputPortResourceTransferComplete(InputPort inputPort)&#10;        {&#10;            ShapeResource resource = inputPort.Pop();&#10;            int shapeTier = 0;&#10;            foreach (ShapeResourceSO shapeResourceSo in allShapeResourceSo)&#10;            {&#10;                if (IsContainPiece(resource, shapeResourceSo))&#10;                    shapeTier++;&#10;            }&#10;&#10;            int amount = 0;&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                if (resource.ShapePieces[i].ShapePieceSo != null)&#10;                    amount += resource.ShapePieces[i].ShapePieceSo.resourceAmount;&#10;            }&#10;&#10;            EventBus.Raise(new ResourceEvent(amount * shapeTier));&#10;&#10;            // We've consumed this resource; return it to the pool to avoid leaking pooled instances&#10;            if (resource != null)&#10;                resource.Release();&#10;        }&#10;&#10;        private bool IsContainPiece(ShapeResource resource, ShapeResourceSO shapeResourceSo)&#10;        {&#10;            if (resource.ShapePieces.Any(piece =&gt; shapeResourceSo.ShapePieces.Contains(piece.ShapePieceSo)))&#10;            {&#10;                return true;&#10;            }&#10;&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/SHS/Machines/ShapeResources/ShapeResource.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/SHS/Machines/ShapeResources/ShapeResource.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;namespace Code.SHS.Machines.ShapeResources&#10;{&#10;    public class ShapeResource&#10;    {&#10;        [field: SerializeField] public ShapePiece[] ShapePieces { get; set; } = new ShapePiece[8];&#10;&#10;        public static ShapeResource Create(ShapePiece[] ResourcePieces)&#10;        {&#10;            ShapeResource shapeResource = new ShapeResource();&#10;            shapeResource.ShapePieces = ResourcePieces;&#10;            return shapeResource;&#10;        }&#10;&#10;        public static ShapeResource Create(ShapeResourceSO so)&#10;        {&#10;            ShapeResource shapeResource = new ShapeResource();&#10;&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                shapeResource.ShapePieces[i] = new(so.ShapePieces[i]);&#10;            }&#10;&#10;            return shapeResource;&#10;        }&#10;&#10;        private ShapeResource()&#10;        {&#10;        }&#10;&#10;        public static ShapeResource Stack(ShapeResource leftResource, ShapeResource rightResource)&#10;        {&#10;            ShapeResource newResource = new ShapeResource();&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                if (leftResource.ShapePieces[i].ShapePieceSo != null)&#10;                {&#10;                    newResource.ShapePieces[i] = leftResource.ShapePieces[i];&#10;                }&#10;                else if (rightResource.ShapePieces[i].ShapePieceSo != null)&#10;                {&#10;                    newResource.ShapePieces[i] = rightResource.ShapePieces[i];&#10;                }&#10;            }&#10;&#10;            return newResource;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using UnityEngine;&#10;&#10;namespace Code.SHS.Machines.ShapeResources&#10;{&#10;    public class ShapeResource&#10;    {&#10;        public ShapePiece[] ShapePieces { get; set; } = new ShapePiece[8];&#10;&#10;        // Simple pool&#10;        private static readonly Stack&lt;ShapeResource&gt; s_Pool = new Stack&lt;ShapeResource&gt;(64);&#10;        private const int MaxPoolSize = 256;&#10;&#10;        // Public factory methods kept for compatibility but now use the pool internally&#10;        public static ShapeResource Create(ShapePiece[] ResourcePieces)&#10;        {&#10;            var shapeResource = Rent();&#10;&#10;            // copy provided pieces into pooled instance&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                shapeResource.ShapePieces[i] = (ResourcePieces != null &amp;&amp; i &lt; ResourcePieces.Length) ? ResourcePieces[i] : default(ShapePiece);&#10;            }&#10;&#10;            return shapeResource;&#10;        }&#10;&#10;        public static ShapeResource Create(ShapeResourceSO so)&#10;        {&#10;            var shapeResource = Rent();&#10;&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                shapeResource.ShapePieces[i] = new ShapePiece(so.ShapePieces[i]);&#10;            }&#10;&#10;            return shapeResource;&#10;        }&#10;&#10;        // Rent: obtain instance from pool or create new&#10;        private static ShapeResource Rent()&#10;        {&#10;            if (s_Pool.Count &gt; 0)&#10;            {&#10;                return s_Pool.Pop();&#10;            }&#10;&#10;            return new ShapeResource();&#10;        }&#10;&#10;        // Return instance to pool and clear references&#10;        public void Release()&#10;        {&#10;            // Clear references to avoid retaining unwanted references&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                ShapePieces[i] = default(ShapePiece);&#10;            }&#10;&#10;            if (s_Pool.Count &lt; MaxPoolSize)&#10;            {&#10;                s_Pool.Push(this);&#10;            }&#10;        }&#10;&#10;        private ShapeResource()&#10;        {&#10;            // ensure array exists (property initializer normally covers this)&#10;            if (ShapePieces == null) ShapePieces = new ShapePiece[8];&#10;        }&#10;&#10;        public static ShapeResource Stack(ShapeResource leftResource, ShapeResource rightResource)&#10;        {&#10;            var newResource = Rent();&#10;&#10;            for (int i = 0; i &lt; 8; i++)&#10;            {&#10;                if (leftResource != null &amp;&amp; leftResource.ShapePieces[i].ShapePieceSo != null)&#10;                {&#10;                    newResource.ShapePieces[i] = leftResource.ShapePieces[i];&#10;                }&#10;                else if (rightResource != null &amp;&amp; rightResource.ShapePieces[i].ShapePieceSo != null)&#10;                {&#10;                    newResource.ShapePieces[i] = rightResource.ShapePieces[i];&#10;                }&#10;                else&#10;                {&#10;                    newResource.ShapePieces[i] = default(ShapePiece);&#10;                }&#10;            }&#10;&#10;            return newResource;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/SHS/Machines/Stacker.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/SHS/Machines/Stacker.cs" />
              <option name="originalContent" value="using Chipmunk.ComponentContainers;&#10;using Code.SHS.Animations;&#10;using Code.SHS.Machines.Ports;&#10;using Code.SHS.Machines.ShapeResources;&#10;using Code.Units.Animations;&#10;using UnityEngine;&#10;using UnityEngine.Serialization;&#10;&#10;namespace Code.SHS.Machines&#10;{&#10;    [RequireComponent(typeof(Animator), typeof(ParameterAnimator), typeof(AnimatorTrigger))]&#10;    public class Stacker : BaseMachine, IInputMachine, IOutputMachine&#10;    {&#10;        // [SerializeField] private CompositeInputPort inputPort;&#10;        //이건 나중에 수정할거임&#10;        [FormerlySerializedAs(&quot;leftBaseInputPort&quot;)] [SerializeField] private InputPort leftInputPort;&#10;        [FormerlySerializedAs(&quot;rightBaseInputPort&quot;)] [SerializeField] private InputPort rightInputPort;&#10;        [SerializeField] private OutputPort outputPort;&#10;        [SerializeField] private ParameterSO activeParameter;&#10;        [SerializeField] private ParameterAnimator parameterAnimator;&#10;        [SerializeField] private AnimatorTrigger animatorTrigger;&#10;&#10;        private bool isProcessing = false;&#10;&#10;        public override void OnInitialize(ComponentContainer componentContainer)&#10;        {&#10;            base.OnInitialize(componentContainer);&#10;            parameterAnimator = this.Get&lt;ParameterAnimator&gt;();&#10;            animatorTrigger = this.Get&lt;AnimatorTrigger&gt;();&#10;&#10;            animatorTrigger.OnAnimationTrigger += HandleAnimationTrigger;&#10;        }&#10;&#10;&#10;        public InputPort GetAvailableInputPort(OutputPort outputPort)&#10;        {&#10;            if (leftInputPort.CanAcceptInputFrom(outputPort))&#10;                return leftInputPort;&#10;            if (rightInputPort.CanAcceptInputFrom(outputPort))&#10;                return rightInputPort;&#10;            return null;&#10;        }&#10;&#10;        public bool CanAcceptResource()&#10;            =&gt; true;&#10;            // =&gt; outputPort.CanOutput();&#10;&#10;        public void InputPortResourceTransferComplete(InputPort inputPort)&#10;        {&#10;            if (leftInputPort.Resource != null &amp;&amp; rightInputPort.Resource != null &amp;&amp; !isProcessing)&#10;            {&#10;                isProcessing = true;&#10;                parameterAnimator.SetParameter(activeParameter);&#10;            }&#10;        }&#10;&#10;        private void HandleAnimationTrigger()&#10;        {&#10;            ShapeResource leftResource = leftInputPort.Pop();&#10;            ShapeResource rightResource = rightInputPort.Pop();&#10;&#10;            ShapeResource stackedResource = ShapeResource.Stack(leftResource, rightResource);&#10;&#10;            outputPort.Output(stackedResource);&#10;            isProcessing = false;&#10;        }&#10;&#10;        public void OnOutputPortComplete(OutputPort port)&#10;        {&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using Chipmunk.ComponentContainers;&#10;using Code.SHS.Animations;&#10;using Code.SHS.Machines.Ports;&#10;using Code.SHS.Machines.ShapeResources;&#10;using Code.Units.Animations;&#10;using UnityEngine;&#10;using UnityEngine.Serialization;&#10;&#10;namespace Code.SHS.Machines&#10;{&#10;    [RequireComponent(typeof(Animator), typeof(ParameterAnimator), typeof(AnimatorTrigger))]&#10;    public class Stacker : BaseMachine, IInputMachine, IOutputMachine&#10;    {&#10;        // [SerializeField] private CompositeInputPort inputPort;&#10;        //이건 나중에 수정할거임&#10;        [FormerlySerializedAs(&quot;leftBaseInputPort&quot;)] [SerializeField] private InputPort leftInputPort;&#10;        [FormerlySerializedAs(&quot;rightBaseInputPort&quot;)] [SerializeField] private InputPort rightInputPort;&#10;        [SerializeField] private OutputPort outputPort;&#10;        [SerializeField] private ParameterSO activeParameter;&#10;        [SerializeField] private ParameterAnimator parameterAnimator;&#10;        [SerializeField] private AnimatorTrigger animatorTrigger;&#10;&#10;        private bool isProcessing = false;&#10;&#10;        public override void OnInitialize(ComponentContainer componentContainer)&#10;        {&#10;            base.OnInitialize(componentContainer);&#10;            parameterAnimator = this.Get&lt;ParameterAnimator&gt;();&#10;            animatorTrigger = this.Get&lt;AnimatorTrigger&gt;();&#10;&#10;            animatorTrigger.OnAnimationTrigger += HandleAnimationTrigger;&#10;        }&#10;&#10;&#10;        public InputPort GetAvailableInputPort(OutputPort outputPort)&#10;        {&#10;            if (leftInputPort.CanAcceptInputFrom(outputPort))&#10;                return leftInputPort;&#10;            if (rightInputPort.CanAcceptInputFrom(outputPort))&#10;                return rightInputPort;&#10;            return null;&#10;        }&#10;&#10;        public bool CanAcceptResource()&#10;            =&gt; true;&#10;            // =&gt; outputPort.CanOutput();&#10;&#10;        public void InputPortResourceTransferComplete(InputPort inputPort)&#10;        {&#10;            if (leftInputPort.Resource != null &amp;&amp; rightInputPort.Resource != null &amp;&amp; !isProcessing)&#10;            {&#10;                isProcessing = true;&#10;                parameterAnimator.SetParameter(activeParameter);&#10;            }&#10;        }&#10;&#10;        private void HandleAnimationTrigger()&#10;        {&#10;            ShapeResource leftResource = leftInputPort.Pop();&#10;            ShapeResource rightResource = rightInputPort.Pop();&#10;&#10;            ShapeResource stackedResource = ShapeResource.Stack(leftResource, rightResource);&#10;&#10;            outputPort.Output(stackedResource);&#10;            isProcessing = false;&#10;&#10;            // We used the left/right resources to form the stacked resource; return them to the pool&#10;            if (leftResource != null)&#10;                leftResource.Release();&#10;            if (rightResource != null)&#10;                rightResource.Release();&#10;        }&#10;&#10;        public void OnOutputPortComplete(OutputPort port)&#10;        {&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Code/SHS/UI/ConstructionButton.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Code/SHS/UI/ConstructionButton.cs" />
              <option name="originalContent" value="using System;&#10;using Chipmunk.GameEvents;&#10;using Code.SHS.Machines;&#10;using Code.SHS.Machines.Events;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Chipmunk.UI&#10;{&#10;    public class ConstructionButton : MonoBehaviour&#10;    {&#10;        [SerializeField] private Button button;&#10;        [SerializeField] private Image iconImage;&#10;        private Image backgroundImage;&#10;        [SerializeField] private Color selectedColor = new Color(0.8f, 0.8f, 0.8f);&#10;        private MachineSO machineSo;&#10;        private Color defaultColor;&#10;&#10;        public void Enable(MachineSO machineSo)&#10;        {&#10;            this.machineSo = machineSo;&#10;            button.interactable = true;&#10;            iconImage.sprite = machineSo.Icon;&#10;            button.onClick.AddListener(OnClickHandler);&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            backgroundImage = GetComponent&lt;Image&gt;();&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            EventBus.Subscribe&lt;MachineSelectEvent&gt;(OnMachineSelected);&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            EventBus.Unsubscribe&lt;MachineSelectEvent&gt;(OnMachineSelected);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            button.onClick.RemoveListener(OnClickHandler);&#10;        }&#10;&#10;        private void OnClickHandler()&#10;        {&#10;            Select();&#10;        }&#10;&#10;        public void Select()&#10;        {&#10;            EventBus.Raise(new MachineSelectEvent(machineSo));&#10;        }&#10;&#10;        private void OnMachineSelected(MachineSelectEvent evt)&#10;        {&#10;            // If this button has not been initialized with a MachineSO yet, ignore&#10;            if (backgroundImage == null) return;&#10;&#10;            if (evt.MachineSo == machineSo)&#10;            {&#10;                backgroundImage.color = selectedColor;&#10;            }&#10;            else&#10;            {&#10;                backgroundImage.color = defaultColor;&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using Chipmunk.GameEvents;&#10;using Code.SHS.Machines;&#10;using Code.SHS.Machines.Events;&#10;using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;namespace Chipmunk.UI&#10;{&#10;    public class ConstructionButton : MonoBehaviour&#10;    {&#10;        [SerializeField] private Button button;&#10;        [SerializeField] private Image iconImage;&#10;        [SerializeField] private Image backgroundImage;&#10;        [SerializeField] private Color selectedColor = new Color(0.8f, 0.8f, 0.8f);&#10;        private MachineSO machineSo;&#10;        private Color defaultColor;&#10;&#10;        public void Enable(MachineSO machineSoArg)&#10;        {&#10;            this.machineSo = machineSoArg;&#10;            button.interactable = true;&#10;            iconImage.sprite = machineSo.Icon;&#10;            button.onClick.AddListener(OnClickHandler);&#10;        }&#10;&#10;        private void Awake()&#10;        {&#10;            if (backgroundImage == null)&#10;                backgroundImage = GetComponent&lt;Image&gt;();&#10;            if (backgroundImage != null)&#10;                defaultColor = backgroundImage.color;&#10;        }&#10;&#10;        private void OnEnable()&#10;        {&#10;            EventBus.Subscribe&lt;MachineSelectEvent&gt;(OnMachineSelected);&#10;        }&#10;&#10;        private void OnDisable()&#10;        {&#10;            EventBus.Unsubscribe&lt;MachineSelectEvent&gt;(OnMachineSelected);&#10;        }&#10;&#10;        private void OnDestroy()&#10;        {&#10;            button.onClick.RemoveListener(OnClickHandler);&#10;        }&#10;&#10;        private void OnClickHandler()&#10;        {&#10;            Select();&#10;        }&#10;&#10;        public void Select()&#10;        {&#10;            EventBus.Raise(new MachineSelectEvent(machineSo));&#10;        }&#10;&#10;        private void OnMachineSelected(MachineSelectEvent evt)&#10;        {&#10;            // If this button has not been initialized with a MachineSO yet, ignore&#10;            if (backgroundImage == null) return;&#10;&#10;            if (evt.MachineSo == machineSo)&#10;            {&#10;                backgroundImage.color = selectedColor;&#10;            }&#10;            else&#10;            {&#10;                backgroundImage.color = defaultColor;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>